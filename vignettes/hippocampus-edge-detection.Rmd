---
title: "Edge Dryspot Detection in Human Hippocampus Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Edge Dryspot Detection in Human Hippocampus Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
The SpatialDryArtifacts R package provides a robust, two-step workflow to identify, classify, and handle edge dryspot artifacts in spatial transcriptomics data, particularly from the 10x Visium platform. These artifacts, often appearing as areas of low gene and UMI counts at tissue edges, can negatively impact downstream analyses.

This guide explains the workflow, details the function parameters, interprets the output, and provides a complete practical example.

## The SpatialDryArtifacts Workflow
The core philosophy is a two-step process: Detect, then Classify. This separates the sensitive task of identifying all potential problem spots from the more nuanced task of deciding what to do with them.

**Step 1: detectEdgeDryspots() — The Detection Phase**
**Goal**: To cast a wide net and identify all spots that could potentially be part of an artifact.
**How does it work**:
Outlier Identification: It first finds individual spots with abnormally low QC metrics (e.g., sum_gene) compared to other spots within the same sample or slide, using a Median Absolute Deviation (MAD) threshold.
Morphological Cleaning: Using helper functions (focal_transformations), it performs image analysis techniques on the spatial coordinates (array_row, array_col) of these outliers. This intelligently fills small gaps and connects nearby outlier spots into contiguous regions, cleaning up noise.
Cluster Detection: It identifies all of these contiguous outlier regions as "problem areas" (problemAreas helper function).
Edge Identification: It specifically checks which of these problem areas are physically touching the outer border of the tissue capture area (clumpEdges helper function).
Key Outputs: This function adds three "raw" data columns to your spe object: _edge, _problem_id, and _problem_size.

**Step 2: classifyEdgeDryspots() — The Decision Phase**

**Goal**: To take the raw detections from Step 1 and apply user-defined rules to assign actionable QC labels.
**How does it work**:
Input: Takes the spe object already processed by detectEdgeDryspots().
Rule-Based Classification: It evaluates each "problem area" based on parameters you provide, such as the minimum cluster size (min_spots) and the proportion of spots within it that have very low UMI counts (removal_threshold).
Label Assignment: It assigns clear, human-readable labels to each spot, like "remove".
Key Outputs: This function adds the final classification columns that you will use for filtering: _classification and _enhanced.

## Parameter Guide
Tuning parameters allows you to adapt the workflow to different tissue types and data quality.

**detectEdgeDryspots() Parameters**
Core Tuning Parameters
*mad_threshold*: (Default: 3) Sets the sensitivity for detecting individual outlier spots based on the QC metric. A lower value (e.g., 1.5-2) is more sensitive and will flag more spots as initial outliers.
*edge_threshold*: (Default: 0.75) The proportion of a cluster's boundary that must be "open" (next to off-tissue spots) to be considered an edge cluster. A lower value (e.g., 0.5) is more aggressive and will classify more clusters as being on the edge.
*min_cluster_size*: (Default: 40) The minimum number of connected spots required to be considered a "problem area" by the morphological cleaning helpers. A lower value (e.g., 15-20) is more sensitive and will detect smaller artifacts.

**Advanced & Data Structure Parameters**
*qc_metric*: (Default: "sum_gene") The column name in colData(spe) to be used for outlier detection. Can be changed to "sum_umi" or another relevant metric.
*samples*: (Default: "sample_id") The column name that uniquely identifies each sample capture area. The function will process each sample independently.
*batch_var*: (Default: "both") Determines the batch for MAD outlier calculation. Can be "sample_id", "slide", or "both" (calculates outliers within each group and combines them).
*shifted*: (Default: FALSE) Logical. Set to TRUE if using Visium data where odd-numbered columns need a coordinate shift to correctly calculate neighbors.

**Utility Parameters**
*name*: (Default: "edge_dryspot") A character string used as the prefix for all output columns added to colData(spe).
*verbose*: (Default: TRUE) If TRUE, the function will print progress messages to the console.
*keep_intermediate*: (Default: FALSE) If TRUE, the intermediate MAD outlier columns will be kept in the final spe object.

**classifyEdgeDryspots() Parameters**
*min_spots*: (Default: 20) The minimum size for a problem area to be considered for the "remove" or "flag" categories. Clusters smaller than this are labeled "small".
*low_umi_threshold*: (Default: 100) The UMI count (sum_umi) below which a spot is considered "low quality" when calculating the removal_threshold.
*removal_threshold*: (Default: 0.5) If the proportion of "low quality" spots within a problem area exceeds this value, the entire area is labeled "remove".
*exclude_slides*: (Default: NULL) An optional character vector of slide IDs. Any edges detected on these slides will be ignored during classification, which is useful if you know a particular slide's edge signal is biological.
*name*: (Default: "edge_dryspot") Must match the name used in detectEdgeDryspots() to find the correct input columns.

**Understanding the output columns**
After running both functions, several columns are added to colData(spe). Here are the most important ones for QC:
*_edge*: Raw Detection: Is the spot part of a cluster touching the tissue border? (TRUE/FALSE)
*_problem_id*: Raw Detection: The ID of the problem area (if any) that this spot belongs to.
*_problem_size*: Raw Detection: The size (number of spots) of the problem area that this spot belongs to.
*_classification*: Final Classification: The action label for this spot ("remove", "flag", "small", "keep").
*_enhanced*: Final Classification: A more detailed label that provides context about the classification
*_true_edges*: Intermediate: The _edge status after applying the exclude_slides filter.


## Loading Data
We'll use the human hippocampus dataset from ExperimentHub:

```{r setup}
pkgload::load_all("..", export_all = TRUE)
knitr::opts_chunk$set(cache = FALSE)
library(SpatialDryArtifacts)
library(ExperimentHub)
library(ggplot2)
library(gridExtra)
```


```{r loadingData}
# Load hippocampus data
eh <- ExperimentHub()
myfiles <- query(eh, "humanHippocampus2024")
spatial_hpc_spe <- myfiles[["EH9605"]]
cat("Total samples:", length(unique(spatial_hpc_spe$sample_id)), "\n")
cat("Total spots:", ncol(spatial_hpc_spe), "\n")
```
Edge Dryspot Detection
We'll demonstrate detection using balanced parameters that provide good sensitivity while avoiding over-detection:

```{r detectingSpot, cache=FALSE}
# Apply edge dryspot detection to all samples
spe_detected <- detectEdgeDryspots(
  spatial_hpc_spe,
  qc_metric = "sum_gene",
  samples = "sample_id",
  mad_threshold = 1.8,
  edge_threshold = 0.2,
  min_cluster_size = 3,
  name = "edge_dryspot"
)

# Apply enhanced classification
spe_classified <- classifyEdgeDryspots(spe_detected)
```

Visualization: QC Metrics and Detection Results
We'll create a comprehensive visualization showing QC metrics and detection results for all samples:
```{r plot, fig.width=16, fig.height=20}
all_samples <- unique(spe_classified$sample_id)

create_sample_plots <- function(sample_id, spe_data) {
  
  spe_sample <- spe_data[, spe_data$sample_id == sample_id]
  coords <- spatialCoords(spe_sample)
  in_tissue <- spe_sample$in_tissue
  
  plot_data <- data.frame(
    x = coords[in_tissue, 1],
    y = coords[in_tissue, 2],
    sum_umi = spe_sample$sum_umi[in_tissue],
    sum_gene = spe_sample$sum_gene[in_tissue],
    expr_chrM_ratio = ifelse(is.na(spe_sample$expr_chrM_ratio[in_tissue]), 0, 
                             spe_sample$expr_chrM_ratio[in_tissue]),
    edge_flagged = spe_sample$edge_dryspot_edge[in_tissue]
  )
  
  base_theme <- theme_void() + 
    theme(plot.title = element_text(size = 8, hjust = 0.5),
          legend.position = "none",
          plot.margin = margin(1, 1, 1, 1, "pt"))
  
  p1 <- ggplot(plot_data, aes(x = x, y = y, color = log10(sum_umi + 1))) +
    geom_point(size = 0.3, alpha = 0.8) +
    scale_color_viridis_c(name = "log10(UMI)") +
    ggtitle(paste(sample_id, "- UMI")) +
    base_theme + coord_fixed()
  
  p2 <- ggplot(plot_data, aes(x = x, y = y, color = log10(sum_gene + 1))) +
    geom_point(size = 0.3, alpha = 0.8) +
    scale_color_viridis_c(name = "log10(Gene)", option = "plasma") +
    ggtitle(paste(sample_id, "- Genes")) +
    base_theme + coord_fixed()
  
  p3 <- ggplot(plot_data, aes(x = x, y = y, color = expr_chrM_ratio)) +
    geom_point(size = 0.3, alpha = 0.8) +
    scale_color_viridis_c(name = "Mito Ratio", option = "inferno") +
    ggtitle(paste(sample_id, "- Mito")) +
    base_theme + coord_fixed()
  
  p4 <- ggplot(plot_data, aes(x = x, y = y, color = edge_flagged)) +
    geom_point(size = 0.3, alpha = 0.8) +
    scale_color_manual(values = c("FALSE" = "lightgray", "TRUE" = "red"), 
                       name = "Edge") +
    ggtitle(paste(sample_id, "- Flagged")) +
    base_theme + coord_fixed()
  
  return(list(p1, p2, p3, p4))
}

samples_per_page <- 4  # 4 samples per page, each sample has 4 plots = 16 plots per page
n_pages <- ceiling(length(all_samples) / samples_per_page)

for (page in 1:n_pages) {
  start_idx <- (page - 1) * samples_per_page + 1
  end_idx <- min(page * samples_per_page, length(all_samples))
  
  page_samples <- all_samples[start_idx:end_idx]
  
  # Collect all plots for this page
  all_plots <- list()
  
  for (sample_id in page_samples) {
    sample_plots <- create_sample_plots(sample_id, spe_classified)
    all_plots <- c(all_plots, sample_plots)
  }
  
  # Arrange all plots in a grid: 4 columns (UMI, Genes, Mito, Flagged) 
  # and as many rows as there are samples on this page
  grid.arrange(
    grobs = all_plots,
    ncol = 4,  # 4 plots per row (one sample per row)
    top = paste("Edge Detection Results - Page", page)
  )
}
```

Classification Summary
Let's examine the enhanced classification system:
```{r classification}
# Create classification summary table
classification_summary <- table(spe_classified$edge_dryspot_enhanced)
print("Enhanced Classification Summary:")
print(classification_summary)

# Calculate percentages
classification_pct <- round(100 * classification_summary / sum(classification_summary), 2)
print("Classification Percentages:")
print(classification_pct)

# Create summary data frame
summary_df <- data.frame(
  Classification = names(classification_summary),
  Count = as.numeric(classification_summary),
  Percentage = as.numeric(classification_pct)
)

print(summary_df)

# Sample-wise summary
sample_summary <- aggregate(
  spe_classified$edge_dryspot_edge, 
  by = list(Sample = spe_classified$sample_id), 
  FUN = function(x) sum(x, na.rm = TRUE)
)
names(sample_summary)[2] <- "Edge_Spots_Detected"

sample_summary$Total_Spots <- aggregate(
  spe_classified$in_tissue, 
  by = list(spe_classified$sample_id), 
  FUN = sum
)$x

sample_summary$Detection_Percentage <- round(
  100 * sample_summary$Edge_Spots_Detected / sample_summary$Total_Spots, 2
)

print("Sample-wise Detection Summary:")
print(sample_summary)
```
Quality Control Validation
Finally, let's validate that flagged spots have lower quality metrics:

```{r validation}
# Create QC comparison data
in_tissue_data <- spe_classified[, spe_classified$in_tissue]

qc_data <- data.frame(
  sum_umi = in_tissue_data$sum_umi,
  sum_gene = in_tissue_data$sum_gene,
  expr_chrM_ratio = ifelse(is.na(in_tissue_data$expr_chrM_ratio), 0, 
                           in_tissue_data$expr_chrM_ratio),
  flagged = in_tissue_data$edge_dryspot_edge
)

# Calculate median differences
flagged_umi <- median(qc_data$sum_umi[qc_data$flagged])
nonflagged_umi <- median(qc_data$sum_umi[!qc_data$flagged])

flagged_gene <- median(qc_data$sum_gene[qc_data$flagged])
nonflagged_gene <- median(qc_data$sum_gene[!qc_data$flagged])

cat("QC Validation Results:\n")
cat("Flagged spots - Median UMI:", flagged_umi, "\n")
cat("Non-flagged spots - Median UMI:", nonflagged_umi, "\n")
cat("UMI difference:", nonflagged_umi - flagged_umi, "\n\n")

cat("Flagged spots - Median Genes:", flagged_gene, "\n")
cat("Non-flagged spots - Median Genes:", nonflagged_gene, "\n")
cat("Gene difference:", nonflagged_gene - flagged_gene, "\n")

# Create validation boxplot
qc_data$flag_status <- ifelse(qc_data$flagged, "Flagged", "Non-Flagged")

validation_plot <- ggplot(qc_data, aes(x = flag_status, y = log10(sum_umi + 1), fill = flag_status)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Flagged" = "lightcoral", "Non-Flagged" = "lightblue")) +
  labs(
    title = "QC Validation: UMI Counts in Flagged vs Non-Flagged Spots",
    x = "Flag Status", y = "log10(UMI Count)"
  ) +
  theme_minimal()

print(validation_plot)
```

Conclusion
This vignette demonstrates:

Edge dryspot detection using balanced parameters on human hippocampus data
Comprehensive visualization showing QC metrics and detection results across all samples
Enhanced classification system with mechanistically-informed categories
Quality control validation confirming that flagged spots have lower quality metrics

The detection successfully identifies problematic spots while preserving high-quality tissue for downstream analysis.
